<?xml version="1.0" encoding="UTF-8"?>

<!DOCTYPE rfc SYSTEM "rfc2629.dtd" [
]>

<?rfc compact="yes"?>
<?rfc iprnotified="no" ?>
<?rfc sortrefs="yes"?>
<?rfc strict="yes"?>
<?rfc symrefs="yes"?>
<?rfc toc="yes"?>
<?rfc tocdepth="4"?>

<rfc docName="draft-ietf-uta-tls-bcp-08" ipr="trust200902" category="bcp">
  <front>
    <title abbrev="TLS Recommendations">Recommendations for Secure Use of TLS and DTLS</title>
    <author initials="Y." surname="Sheffer" fullname="Yaron Sheffer">
      <organization abbrev="Porticor">Porticor</organization>
      <address>
        <postal>
          <street>29 HaHarash St.</street>
          <city>Hod HaSharon</city>
          <code>4501303</code>
          <country>Israel</country>
        </postal>
        <email>yaronf.ietf@gmail.com</email>
      </address>
    </author>
    <author initials="R." surname="Holz" fullname="Ralph Holz">
      <organization abbrev="TUM">Technische Universitaet Muenchen</organization>
      <address>
        <postal>
          <street>Boltzmannstr. 3</street>
          <city>Garching</city>
          <code>85748</code>
          <country>Germany</country>
        </postal>
        <email>ralph.ietf@gmail.com</email>
      </address>
    </author>
    <author initials="P." surname="Saint-Andre" fullname="Peter Saint-Andre">
      <organization>&amp;yet</organization>
      <address>
        <email>peter@andyet.com</email>
        <uri>https://andyet.com/</uri>
      </address>
    </author>
    <date/>
    <workgroup>UTA</workgroup>
    <keyword>Internet-Draft</keyword>
    <abstract>
      <t>Transport Layer Security (TLS) and Datagram Transport Layer Security (DTLS) are widely used to protect data exchanged over application protocols such as HTTP, SMTP, IMAP, POP, SIP, and XMPP.  Over the last few years, several serious attacks on TLS have emerged, including attacks on its most commonly used cipher suites and modes of operation.  This document provides recommendations for improving the security of deployed services that use TLS and DTLS. The recommendations are applicable to the majority of use cases.</t>
    </abstract>
  </front>
  <middle>

    <section title="Introduction" anchor="d1e381">
      <t>Transport Layer Security (TLS) <xref target='RFC5246'/> and Datagram Transport Security Layer (DTLS) <xref target='RFC6347'/> are widely used to protect data exchanged over application protocols such as HTTP, SMTP, IMAP, POP, SIP, and XMPP.  Over the last few years, several serious attacks on TLS have emerged, including attacks on its most commonly used cipher suites and modes of operation.  For instance, both the AES-CBC <xref target='RFC3602'/> and RC4 <xref target='I-D.ietf-tls-prohibiting-rc4'/> encryption algorithms, which together are the most widely deployed ciphers, have been attacked in the context of TLS.  A companion document <xref target='I-D.ietf-uta-tls-attacks'/> provides detailed information about these attacks.</t>
      <t>Because of these attacks, those who implement and deploy TLS and DTLS need updated guidance on how TLS can be used securely.  This document provides guidance for deployed services as well as for software implementations, assuming the implementer expects his or her code 
to be deployed in environments defined in the following section. 
In fact, this document calls for the deployment of algorithms that 
are widely implemented but not yet widely deployed.  Concerning 
deployment, this document targets a wide audience, namely all 
deployers who wish to add authentication (be it one-way only or mutual), confidentiality, and data integrity protection
to their communications.
</t>
      <t>The recommendations herein take into consideration the security of various mechanisms, their technical maturity and interoperability, and their prevalence in implementations at the time of writing.  Unless it is explicitly called out that a recommendation applies to TLS alone or to DTLS alone, each recommendation applies to both TLS and DTLS.</t>
      <t>
         It is expected that the TLS 1.3 specification will resolve many of
         the vulnerabilities listed in this document. A system that deploys
         TLS 1.3 will have fewer vulnerabilities than TLS 1.2 or below. This
         document is likely to be updated after TLS 1.3 gets noticeable
         deployment.
      </t>
      <t>
	These are minimum recommendations for the use of TLS in the vast
        majority of implementation and deployment scenarios, with the 
        exception of unauthenticated TLS (see <xref target='sec-app'/>). 
	Other specifications that reference this document can have stricter
	requirements related to one or more aspects of the protocol,
	based on their particular circumstances (e.g., for use with a 
        particular application protocol); when that is the case,
	implementers are advised to adhere to those stricter requirements.
        Furthermore, this document provides a floor, not a ceiling, so stronger 
        options are always allowed (e.g., depending on differing evaluations 
        of the importance of cryptographic strength vs. computational load).
      </t>
      <t>Community knowledge about the strength of various algorithms and feasible attacks can change quickly, and experience shows that a security BCP is a point-in-time statement.  Readers are advised to seek out any errata or updates that apply to this document.</t>
    </section>
    
    <section title="Terminology" anchor="terms">
      <t>A number of security-related terms in this document are used in the sense defined in <xref target="RFC4949"/>.</t>
      <t>The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT", "SHOULD", "SHOULD NOT", "RECOMMENDED", "MAY", and "OPTIONAL" in this document are to be interpreted as described in <xref target="RFC2119"/>.</t>
    </section>

    <section title="General Recommendations" anchor="rec">
    <t>This section provides general recommendations on the secure use of TLS. Recommendations related to cipher
    suites are discussed in the following section.</t>

      <section title="Protocol Versions">
      <section title="SSL/TLS Protocol Versions" anchor="rec-versions">
        <t>It is important both to stop using old, less secure versions of SSL/TLS 
        and to start using modern, more secure versions; therefore, the following
  are the recommendations concerning TLS/SSL protocol versions:</t>
        <t>
          <list style='symbols'>
            <t>Implementations MUST NOT negotiate SSL version 2.
               <vspace blankLines='1'/>
               Rationale: Today, SSLv2 is considered insecure <xref target='RFC6176'/>.
            </t>
            <t>Implementations MUST NOT negotiate SSL version 3.
               <vspace blankLines='1'/>
               Rationale: SSLv3 <xref target='RFC6101'/> was an improvement over SSLv2 and plugged some significant security holes, but did not support strong cipher suites. SSLv3 does not support TLS extensions, some of which (e.g., renegotiation_info) are security-critical.  In addition, with the emergence of the POODLE attack <xref target='POODLE'/>, SSLv3 is now widely recognized as fundamentally insecure.
            </t>
            <t>Implementations SHOULD NOT negotiate TLS version 1.0 <xref target='RFC2246'/>.
               <vspace blankLines='1'/>
               Rationale: TLS 1.0 (published in 1999) does not support many modern, strong cipher suites. In addition, TLS 1.0 lacks a per-record IV for CBC-based cipher suites and does not warn against common padding errors.
            </t>
            <t>Implementations SHOULD NOT negotiate TLS version 1.1 <xref target='RFC4346'/>.
               <vspace blankLines='1'/>
               Rationale: TLS 1.1 (published in 2006) is a security improvement over TLS 1.0, but still does not support certain stronger cipher suites.
            </t>
            <t>Implementations MUST support TLS 1.2 <xref target='RFC5246'/> and MUST prefer to negotiate TLS version 1.2 over earlier versions of TLS.
               <vspace blankLines='1'/>
               Rationale: Several stronger cipher suites are available only with TLS 1.2 (published in 2008). In fact, the cipher suites recommended by this document
	       (<xref target="rec-cipher"/> below) are only available in TLS 1.2.
            </t>
          </list>
        </t>
        <t>This BCP applies to TLS 1.2. It is not safe for readers to assume that the recommendations in this BCP apply
	to any future version of TLS.</t>
      </section>
      
      <section title="DTLS Protocol Versions">
        <t>DTLS, an adaptation of TLS for UDP datagrams, was introduced when TLS 1.1 was published.  The following are the recommendations with respect to DTLS:</t>
 <t>
 <list style="symbols">
<t>Implementations MAY negotiate DTLS version 1.0 <xref target="RFC4347"/>.
<vspace blankLines='1'/>
  Version 1.0 of DTLS correlates to version 1.1 of TLS (see above).
</t>
<t>Implementations MUST support, and prefer to negotiate, DTLS version 1.2 <xref target="RFC6347"/>.
<vspace blankLines='1'/>
  Version 1.2 of DTLS correlates to Version 1.2 of TLS 1.2 (see above).
  (There is no Version 1.1 of DTLS.)
</t>
</list>
</t>
    </section>

      <section title="Fallback to Lower Versions" anchor="rec-fallback">
      <t>
       Clients that â€œfall back" to lower versions of the protocol after the server
  rejects higher versions of the protocol MUST NOT fall back to SSLv3.
</t>
<t>
  Rationale: Some client implementations revert to lower versions of TLS or even
  to SSLv3 if the server rejected higher versions of the protocol.
  This fallback can be forced by a man in the middle (MITM) attacker.
  TLS 1.0 and SSLv3 are significantly less secure than TLS
  1.2, the version recommended by this document.  While TLS 1.0-only
  servers are still quite common, IP scans show that SSLv3-only servers
  amount to only about 3% of the current Web server population.  
  (At the time of this writing, an explicit method for preventing downgrade 
  attacks is being defined in <xref target='I-D.ietf-tls-downgrade-scsv'/>.)
  </t>
      </section>
      </section>
      
      <section title="Strict TLS">
      <t>
      To prevent SSL Stripping:
      
      <list style="symbols">
      <t>
	In cases where an
	application protocol allows implementations or deployments a choice
	between strict TLS configuration and dynamic upgrade from
	unencrypted to TLS-protected traffic (such as STARTTLS), clients and
	servers SHOULD prefer strict TLS configuration.
	</t>
      <t>
        In many application protocols, clients can be configured to
        use TLS no matter whether the server offers TLS during a 
        protocol exchange or advertises support for TLS (e.g., through
        a flag indicating that TLS is required).  Application clients 
        SHOULD use TLS by default, and disable this default only through 
        explicit configuration by the user. 
      </t>
      <t>
      HTTP client and server implementations MUST support the HTTP Strict Transport
      Security (HSTS) header <xref target="RFC6797"/>, in order to allow Web servers to 
      advertise that they are
      willing to accept TLS-only clients.
      </t>
      <t>
      When applicable, Web servers SHOULD use HSTS to indicate that they are willing to accept TLS-only clients.
      </t>
      </list>
      </t>
      <t>
      Rationale: Combining unprotected and TLS-protected communication opens
      the way to SSL Stripping and similar attacks, since an initial part of
      the communication is not integrity protected and therefore can be manipulated
      by an attacker whose goal is to keep the communication in the clear. 
      </t>
      </section>

      <section title="Compression" anchor="rec-compress">
        <t>Implementations and deployments SHOULD disable TLS-level compression (<xref target="RFC5246"/>, Section 6.2.2).</t>
	<t>
	Rationale: TLS compression has been subject to security attacks,
	such as the CRIME attack.</t>
	<t>Implementers should note that compression at higher protocol levels can allow an active attacker to extract cleartext
	information from the connection. The BREACH attack is one such case. These issues can only be mitigated outside
	of TLS and are thus out of scope of the current document. See Section 2.6 of <xref target="I-D.ietf-uta-tls-attacks"/> for 
	further details.</t>
      </section>

      <section title="TLS Session Resumption" anchor="rec-resume">
        <t>If TLS session resumption is used, care ought to be taken to do so safely. In particular,
	when using session tickets <xref target='RFC5077'/>, the resumption information
	MUST be authenticated 
	and encrypted to prevent modification or eavesdropping by an attacker. Further recommendations apply to session tickets:
	<list style="symbols">
	<t>A strong cipher suite MUST be used when encrypting the ticket (as least as strong as the main TLS cipher suite).</t>
	<t>Ticket keys MUST be changed regularly, e.g., once every week, so as not to negate the benefits of forward secrecy
	(see <xref target='sec-pfs'/> for details on forward secrecy).</t>
	<t>For similar reasons, session ticket validity SHOULD be limited to a reasonable duration (e.g., half as long as ticket key validity).</t>
	</list>
	</t>
	<t>
	Rationale: session resumption is another kind of TLS handshake, and therefore
	must be as secure as the initial handshake. This document
	(<xref target="detail"/>) recommends the use
	of cipher suites that provide forward secrecy, i.e. that prevent an attacker
	who gains momentary access to the TLS endpoint (either client or server)
	and its secrets	from reading
	either past or future communication. The tickets must be managed so as not to
	negate this security property.
	</t>
      </section>
      
      <section title="TLS Renegotiation">
      <t>
      Where handshake renegotiation is implemented, both clients and servers MUST implement the renegotiation_info extension, 
      as defined in <xref target="RFC5746"/>.
      </t>
      <t>To counter the Triple Handshake attack, we adopt the recommended countermeasures from <xref target="triple-handshake"/>:
      TLS clients SHOULD apply the same validation policy for all certificates received over a connection, bind the master secret to the full handshake, and bind the abbreviated session resumption handshake to the original full handshake.  In some usages, it may be simplest to refuse any change of certificates during renegotiation.
      </t>
      </section>

      <section title="Server Name Indication">
      <t>
      TLS implementations MUST support the Server Name Indication (SNI) extension
      for those higher level protocols which would benefit from it, including HTTPS.
      However, unlike implementation, the use of SNI in particular circumstances
      is a matter of local policy.
      </t>
      <t>
      Rationale: SNI supports deployment of multiple TLS-protected virtual servers on a single
      address, and therefore enables fine-grained security for these virtual servers,
      by allowing each one to have its own certificate.
      </t>
      </section>
      
    </section>

    <section title="Recommendations: Cipher Suites" anchor="detail">

      <t>TLS and its implementations provide considerable flexibility in the
         selection of cipher suites.  Unfortunately, some available cipher
         suites are insecure, some do not provide the targeted security
         services, and some no longer provide enough security.  Incorrectly
         configuring a server leads to no or reduced security.  This section
         includes recommendations on the selection and negotiation of
         cipher suites.
         </t>

      <section title="General Guidelines" anchor="rec-cipher-guidelines">
        <t>
	Cryptographic algorithms weaken over time as cryptanalysis improves.  In other
  words, as time progresses, algorithms that were once considered strong but are
  now weak, need to be phased out over time and replaced with more secure
  cipher suites to ensure that desired security properties still hold.
  SSL/TLS has been in existence for almost 20 years
  at this point and this section provides some much needed recommendations
  concerning cipher suite selection:
	</t>
        <t>
          <list style='symbols'>
            <t>Implementations MUST NOT negotiate the cipher suites with NULL encryption.
               <vspace blankLines='1'/>
               Rationale: The NULL cipher suites do not encrypt traffic and so provide
  no confidentiality services. Any entity in the network with access to the
  connection can view the plaintext of contents being exchanged by the client and
  server.
            </t>
            <t>Implementations MUST NOT negotiate RC4 cipher suites. 
               <vspace blankLines='1'/>
               Rationale: The RC4 stream cipher has a variety of cryptographic weaknesses, as documented in <xref target='I-D.ietf-tls-prohibiting-rc4'/>.
	       We note that this guideline does not apply to DTLS,
	       which specifically forbids the use of RC4.
            </t>
	    <t>Implementations MUST NOT negotiate cipher suites offering less than 112 bits of security, including the so-called "export-level" encryption (which provide 40 or 56 bits of security).
            <vspace blankLines='1'/>
            Rationale: Based on <xref target='RFC3766'/>, at least 112 bits of security 
            is needed.  40-bit and 56-bit security are considered insecure today.  
            TLS 1.1 and 1.2 never negotiate 40-bit or 56-bit export ciphers.
            </t>
            <t>Implementations SHOULD NOT negotiate cipher suites that use algorithms offering less than 128 bits of security.
	    
               <vspace blankLines='1'/>
Rationale: Cipher suites that offer between 112-bits and 128-bits of security
  are not considered weak at this time, however it is expected that their useful lifespan
  is short enough to justify supporting stronger cipher suites at this time.
  128-bit ciphers are expected to remain secure for at least several years,
  and 256-bit ciphers "until the next fundamental technology breakthrough".
  Note that
  some legacy cipher suites (e.g., 168-bit 3DES) have an effective
  key length which is smaller than their nominal key length (112
  bits in the case of 3DES).  Such cipher suites should be evaluated
   according to their effective key length.
            </t>
            <t>Implementations MUST support, and SHOULD prefer to negotiate, cipher suites offering forward secrecy, such as those in the Ephemeral Diffie-Hellman and Elliptic Curve Ephemeral Diffie-Hellman ("DHE" and "ECDHE") families.
               <vspace blankLines='1'/>
               Rationale: Forward secrecy (sometimes called "perfect forward secrecy") prevents the recovery of information that was encrypted with older session keys, thus limiting the amount of time during which attacks can be successful. See <xref target="sec-pfs"/> for a detailed discussion.
            </t>
          </list>
        </t>
	</section>
	
	<section title="Recommended Cipher Suites" anchor="rec-cipher">
        <t>Given the foregoing considerations, implementation and deployment of the following cipher suites
	is RECOMMENDED:</t>
        <t>
          <list style='symbols'>
            <t>TLS_DHE_RSA_WITH_AES_128_GCM_SHA256</t>
            <t>TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256</t>
            <t>TLS_DHE_RSA_WITH_AES_256_GCM_SHA384</t>
            <t>TLS_ECDHE_RSA_WITH_AES_256_GCM_SHA384</t>
          </list>
        </t>
        <t>These cipher suites are supported only in TLS 1.2 because they
	are authenticated encryption (AEAD) algorithms <xref target="RFC5116"/>.</t>
        <t>Typically, in order to prefer these suites, the order of suites needs to be explicitly configured in server software.</t>
        <t>Some devices have hardware support for AES-CCM but not AES-GCM.  There are even devices that do not
	support public key cryptography at all. This BCP does not cover such devices.</t>

	<section title="Implementation Details" anchor="detail-neg">
          <t>Clients SHOULD include TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256 as the first proposal to any server, unless they have prior knowledge that the server cannot respond to a TLS 1.2 client_hello message.</t>
          <t>Servers SHOULD prefer this cipher suite whenever it is proposed, even if it is not the first proposal.</t>
          <t>Clients are of course free to offer stronger cipher suites, e.g., using AES-256; when they do, the server SHOULD prefer the stronger cipher suite unless there are compelling reasons (e.g., seriously degraded performance) to choose otherwise.</t>
          <t>This document does not change the mandatory-to-implement TLS cipher suite(s) prescribed by TLS or application protocols using TLS. To maximize interoperability, RFC 5246 mandates implementation of the TLS_RSA_WITH_AES_128_CBC_SHA cipher suite, which is significantly weaker than the cipher suites recommended here. Implementers should consider the interoperability gain against the loss in security when deploying that cipher suite. Other application protocols specify other cipher suites as mandatory to implement (MTI).</t>
          <t>Note that some profiles of TLS 1.2 use different cipher suites. For example, <xref target="RFC6460"/> defines a profile that uses the TLS_ECDHE_ECDSA_WITH_AES_128_GCM_SHA256 and TLS_ECDHE_ECDSA_WITH_AES_256_GCM_SHA384 cipher suites.</t>
          <t><xref target="RFC4492"/> allows clients and servers to negotiate ECDH parameters (curves).  Both clients and servers SHOULD include the "Supported Elliptic Curves" extension <xref target="RFC4492"/>.  For interoperability, clients and servers SHOULD support the NIST P-256 (secp256r1) curve <xref target="RFC4492"/>. In addition, clients SHOULD send an ec_point_formats extension with a single element, "uncompressed".</t>
        </section>

      </section>

      <section title="Public Key Length" anchor="rec-keylength">
      <t>
      When using the cipher suites recommended in this document, two public keys are 
      normally used in the TLS handshake: one for the Diffie-Hellman key agreement
      and one for server authentication. Where a client certificate is used, a third 
      public key is added.
      </t>
     <t>With a key exchange based on modular Diffie-Hellman ("DHE" cipher suites), DH key lengths of at least 2048 bits are RECOMMENDED.</t>
<t> Rationale: For various reasons, in practice DH keys are typically generated in lengths that are powers of two (e.g., 2^10 = 1024 bits, 2^11 = 2048 bits, 2^12 = 4096 bits). Because a DH key of 1228 bits would be roughly equivalent to only an 80-bit symmetric key <xref target='RFC3766'/>, it is better to use keys longer than that for the "DHE" family of cipher suites. A DH key of 1926 bits would be roughly equivalent to a 100-bit symmetric key <xref target='RFC3766'/> and a DH key of 2048 bits might be sufficient for at least the next 10&nbsp;years. See <xref target="detail-alt"/> for additional information on the use of modular Diffie-Hellman in TLS.
</t>
<t>As noted in <xref target='RFC3766'/>, correcting for the emergence of a TWIRL machine would imply that 1024-bit DH keys yield about 65 bits of equivalent strength and that a 2048-bit DH key would yield about 92 bits of equivalent strength.</t>
<t>With regard to ECDH keys, the IANA named curve registry contains 160-bit elliptic curves which are considered to be roughly equivalent to only an 80-bit symmetric key <xref target='ECRYPT-II'/>.   The use of curves of less than 192-bits is NOT RECOMMENDED.</t>
<t>When using RSA servers SHOULD authenticate using certificates with at least a 2048-bit modulus for the public key.  In addition, the use of the SHA-256 hash algorithm is RECOMMENDED (see <xref target="CAB-Baseline"/> for more details). Clients SHOULD indicate to servers that they request SHA-256, by using the "Signature Algorithms" extension defined in TLS&nbsp;1.2. </t>
      </section>

	<section title="Modular vs. Elliptic Curve DH Cipher Suites" anchor="detail-alt">
      <t>Not all TLS implementations support both modular and elliptic curve Diffie-Hellman groups, as
      required by <xref target="rec-cipher"/>. Some implementations are severely limited in
      the length of DH values. When such implementations need to be accommodated,
      we recommend using (in priority order):</t>
        <t>
          <list style="numbers">
            <t>Elliptic Curve DHE with negotiated parameters <xref target='RFC5289'/></t>
            <t>TLS_DHE_RSA_WITH_AES_128_GCM_SHA256 <xref target="RFC5288"/>, with 2048-bit Diffie-Hellman parameters</t>
            <t>TLS_DHE_RSA_WITH_AES_128_GCM_SHA256, with 1024-bit parameters.</t>
          </list>
        </t>
        <t>Rationale: Although Elliptic Curve Cryptography is widely deployed there are some communities where its uptake has been limited for several reasons, including its complexity compared to modular arithmetic and longstanding perceptions of IPR concerns (which, for the most part, have now been resolved <xref target='RFC6090'/>).  Note that ECDHE cipher suites exist for both RSA and ECDSA certificates so moving to ECDHE cipher suites does not require moving away from RSA based certificates.  On the other hand, there are two related issues hindering effective use of modular Diffie-Hellman cipher suites in TLS:</t>
        <t>
          <list style="symbols">
            <t>There are no standardized, widely implemented protocol mechanisms to negotiate the DH groups or parameter lengths supported by client and server.</t>
            <t>Many servers choose DH parameters of 1024 bits or fewer.</t>
            <t>There are widely deployed client implementations that reject received DH parameters if they are longer than 1024 bits.  In
                 addition, several implementations do not perform appropriate validation of group parameters and are vulnerable to attacks referenced in Section 2.9 of <xref target='I-D.ietf-uta-tls-attacks'/></t>
          </list>
        </t>
        <t>We note that with DHE and ECDHE cipher suites, the TLS master key only depends on the Diffie-Hellman parameters and not on the strength of the RSA certificate; moreover, 1024 bit modular DH parameters are generally considered insufficient at this time.</t>
        <t>With modular ephemeral DH, deployers SHOULD carefully evaluate interoperability vs. security considerations when configuring their TLS endpoints.</t>
      </section>
      
      <section title="Truncated HMAC">
      <t>Implementations MUST NOT use the Truncated HMAC extension, defined in Section 7 of <xref target="RFC6066"/>.
</t>
<t>
Rationale: the extension does not apply to the AEAD
      cipher suites recommended above. However it does apply to most other TLS cipher suites. Its use
      has been shown to be insecure in <xref target="PatersonRS11"/>.
      </t>
      </section>
    </section>
    
          <section title="Applicability Statement" anchor="sec-app">

        <t>The deployment recommendations of this document address the operators of application layer services that are most commonly used on the Internet, including, but not limited to:</t>
        <t>
          <list style="symbols">
            <t>Operators of web servers that wish to protect HTTP with TLS.</t>
            <t>Operators of email servers who wish to protect the application-layer protocols with TLS (e.g., IMAP, POP3 or SMTP).</t>
            <t>Operators of instant-messaging services who wish to protect their application-layer protocols with TLS (e.g., XMPP or IRC).</t>
          </list>
        </t>

        <section title="Security Services">
          <t>This document provides recommendations for an audience that wishes to secure their communication with TLS to achieve the following:</t>
          <t>
            <list style="symbols">
              <t>Confidentiality: all application-layer communication is encrypted with the goal that no party should be able to decrypt it except the intended receiver.</t>
              <t>Data integrity: any changes made to the communication in transit are detectable by the receiver.</t>
              <t>Authentication: an end-point of the TLS communication is authenticated as the intended entity to communicate with.</t>
            </list>
          </t>
          <t>With regard to authentication, TLS enables authentication of one or both end-points in the communication. Although some TLS usage scenarios do not require authentication, those scenarios are not in scope for this document (a rationale for this decision is provided under <xref target="unauth-opp"/>).</t>
          <t>If deployers deviate from the recommendations given in this document, they MUST verify that they do not need one of the foregoing security services.</t>
          <t>This document applies only to environments where confidentiality is required. It recommends algorithms and configuration options that enforce secrecy of the data-in-transit.</t>
          <t>This document also assumes that data integrity protection is always one of the goals of a deployment. In cases where integrity is not required, it does not make sense to employ TLS in the first place. There are attacks against confidentiality-only protection that utilize the lack of integrity to also break confidentiality (see for instance <xref target="DegabrieleP07"/> in the context of IPsec).</t>
          <t>The intended audience covers those services that are most commonly used on the Internet. Typically, all communication between TLS clients and TLS servers requires all three of the above security services. This is particularly true where TLS clients are user agents like Web browsers or email software.</t>
          <t>This document does not address the rarer deployment scenarios where one of the above three properties is not desired, such as the use case described under <xref target="unauth-opp"/> below.  Another example of an audience not needing confidentiality is the following: a monitored network where the authorities in charge of the respective traffic domain require full access to unencrypted (plaintext) traffic, and where users collaborate and send their traffic in the clear.</t>
        </section>
        <section title="Unauthenticated TLS and Opportunistic Security" anchor="unauth-opp">
          <t>Several important applications use TLS to protect data between a TLS client and a TLS server, but do so without the TLS client necessarily verifying the server's certificate. This practice is often called "unauthenticated TLS".  The reader is referred to <xref target="I-D.ietf-dane-smtp-with-dane"/> for an example and an explanation of why this less secure practice will likely remain common in the context of SMTP (especially for MTA-to-MTA communications).  The practice is also encountered in similar contexts such as server-to-server traffic on the XMPP network (where multi-tenant hosting environments make it difficult for operators to obtain proper certificates for all of the domains they service).</t>
          <t>Furthermore, in some scenarios the use of TLS itself is optional, i.e. the client decides dynamically ("opportunistically") whether to use TLS with a particular server or to connect in the clear.  This practice, often called "opportunistic security", and is described at length in Section 2 of <xref target="I-D.farrelll-mpls-opportunistic-encrypt"/>.</t>
          <t>It can be argued that the recommendations provided in this document ought to apply equally to unauthenticated TLS as well as authenticated TLS.  That would keep TLS implementations and deployments in sync, which is a desirable property given that servers can be used simultaneously for unauthenticated TLS and for authenticated TLS (indeed, a server cannot know whether a client might attempt authenticated or unauthenticated TLS). On the other hand, it has been argued that some of the recommendations in this document might be too strict for unauthenticated scenarios and that any security is better than no security at all (i.e., sending traffic in the clear), even if it means deploying outdated protocol versions and ciphers in unauthenticated scenarios.  The sense of the UTA Working Group was to complete work on this document about authenticated TLS and to initiate work on a separate document about unauthenticated TLS.</t>
          <t>In summary: this document does not apply to unauthenticated TLS use cases.</t>
        </section>
      </section>


    <section title="IANA Considerations" anchor="sec_IANA_Considerations">
      <t>This document requests no actions of IANA. [Note to RFC Editor: please remove this whole section before publication.]</t>
    </section>

    <section title="Security Considerations" anchor="sec">
    <t>This entire document discusses the security practices directly affecting applications
    using the TLS protocol. This section contains broader security considerations related
    to technologies used in conjunction with or by TLS.</t>
      <section title="Host Name Validation">
	<t>
	Application authors should take note that TLS implementations
	frequently do not validate host names and must therefore determine if
	the TLS implementation they are using does and, if not, write their own
	validation code or consider changing the TLS implementation.
	</t>
	<t>
	It is noted that the requirements regarding host name validation (and in general,
	binding between the TLS layer and the protocol that runs above it) vary between different
	protocols. For HTTPS, these requirements are defined by Section 3 of <xref target="RFC2818"/>.
	</t>
	<t>
	Readers are referred to <xref target="RFC6125"/> for further details regarding 
	generic host name validation in the TLS context. In addition, the RFC contains a long 
	list of example protocols, some of which implement a policy very different from HTTPS.
	</t>
	<t>
	If the host name is discovered indirectly and in an insecure manner
	(e.g., by an insecure DNS query for an MX or SRV record), it SHOULD
	NOT be used as a reference identifier <xref target="RFC6125"/> even when it matches
	the presented certificate.  This proviso does not apply if the host
	name is discovered securely (for further discussion, see for example
	<xref target="I-D.ietf-dane-srv"/> and <xref target="I-D.ietf-dane-smtp-with-dane"/>).
 	</t>
        <t>
        Host name validation typically applies only to the leaf "end entity"
        certificate. Naturally, in order to ensure proper authentication in
        the context of the PKI, application clients need to verify the entire 
        certification path in accordance with <xref target='RFC5280'/> (see also 
        <xref target='RFC6125'/>).
 	</t>
      </section>

	<section title="AES-GCM" anchor="sec-aes">
        <t>
	<xref target="rec-cipher"/> above recommends the use of the AES-GCM authenticated
	encryption algorithm.
Please refer to <xref target="RFC5246"/>, Section 11 for general security considerations when using TLS 1.2, and to <xref target="RFC5288"/>, Section 6 for security considerations that apply specifically to AES-GCM when used with TLS.</t>
      </section>
      <section title="Forward Secrecy" anchor="sec-pfs">
        <t>Forward secrecy (also often called Perfect Forward Secrecy or "PFS" and defined in <xref target="RFC4949"/>) is a defense against an attacker who records encrypted conversations where the session keys are only encrypted with the communicating parties' long-term keys. Should the attacker be able to obtain these long-term keys at some point later in time, he will be able to decrypt the session keys and thus the entire conversation. In the context of TLS and DTLS, such compromise of long-term keys is not entirely implausible. It can happen, for example, due to:</t>
        <t>
          <list style="symbols">
            <t>A client or server being attacked by some other attack vector, and the private key retrieved.</t>
            <t>A long-term key retrieved from a device that has been sold or otherwise decommissioned without prior wiping.</t>
            <t>A long-term key used on a device as a default key <xref target="Heninger2012"/>.</t>
            <t>A key generated by a Trusted Third Party like a CA, and later retrieved from it either by extortion or compromise <xref target="Soghoian2011"/>.</t>
            <t>A cryptographic break-through, or the use of asymmetric keys with insufficient length <xref target="Kleinjung2010"/>.</t>
            <t>Social engineering attacks against system administrators.</t>
            <t>Collection of private keys from inadequately protected backups.</t>
          </list>
        </t>
        <t>
Forward secrecy ensures in such cases that the session keys cannot be determined even by an attacker who obtains the long-term keys some time after the conversation. It also protects against an attacker who is in possession of the long-term keys, but remains passive during the conversation.</t>
        <t>
Forward secrecy is generally achieved by using the Diffie-Hellman scheme to derive session keys. The Diffie-Hellman scheme has both parties maintain private secrets and send parameters over the network as modular powers over certain cyclic groups. The properties of the so-called Discrete Logarithm Problem (DLP) allow to derive the session keys without an eavesdropper being able to do so. There is currently no known attack against DLP if sufficiently large parameters are chosen. A variant of the Diffie-Hellman scheme uses Elliptic Curves instead of the originally proposed modular arithmetics.</t>
        <t>Unfortunately, many TLS/DTLS cipher suites were defined that do not feature forward secrecy, e.g., TLS_RSA_WITH_AES_256_CBC_SHA256.  We thus advocate strict use of forward-secrecy-only ciphers.</t>
      </section>
      
      <section title="Diffie-Hellman Exponent Reuse">
      <t>
      For performance reasons, many TLS implementations reuse Diffie-Hellman and Elliptic Curve
      Diffie-Hellman exponents
      across multiple connections. Such reuse can result in major
      security issues:
      <list style="symbols">
      <t>If exponents are reused for a long time (e.g., more than a few hours), an attacker
      who gains access to the host can decrypt previous connections. In other words,
      exponent reuse negates the effects of forward secrecy.</t>
      <t>TLS implementations that reuse exponents should test the DH public key they
      receive for group membership, in order to avoid some known attacks. These tests are not 
      standardized in TLS at the time of writing. See <xref target="RFC6989"/> for recipient tests
      required of IKEv2 implementations that reuse DH exponents.</t>
      </list>
      </t>
      </section>
      <section title="Certificate Revocation">
      <t>Unfortunately, no mechanism exists at this time that we can recommend as a complete and efficient solution for the problem of checking the revocation status of common public key certificates (a.k.a. PKIX certificates, <xref target='RFC5280'/>).  The current state of the art is as follows:</t>
      <t>
      <list style='symbols'>
      <t>Although Certificate Revocation Lists (CRLs) are the most widely supported
         mechanism for distributing revocation information, they have known scaling
         challenges that limit their usefulness (despite workarounds such as partitioned
         CRLS and delta CRLs).</t>
      <t>Proprietary mechanisms that embed revocation lists in the Web browser's 
         configuration database cannot scale beyond a small number of the most 
         heavily used Web servers.</t>
      <t>The On-Line Certification Status Protocol (OCSP) <xref target='RFC6960'/>
         presents both scaling
         and privacy issues. In addition, clients typically "soft-fail", meaning 
         that they do not abort the TLS connection if the OCSP server does not 
         respond (however, this might be a workaround to avoid denial of service
         attacks if an OSCP responder is taken offline).</t>
      <t>OCSP stapling (Section 8 of <xref target="RFC6066"/>) resolves the 
         operational issues with OCSP, but is still ineffective in the presence of 
         a MITM attacker because the attacker can simply ignore the client's
         request for a stapled OCSP response.</t>
      <t>OCSP stapling as defined in <xref target="RFC6066"/> does not extend to 
         intermediate certificates used in a certificate chain. 
         Although <xref target="RFC6961"/> addresses this shortcoming, it is a recent 
         addition without much deployment.</t>
      <t>Both CRLs and OSCP depend on relatively reliable connectivity to the 
         Internet, which might not be available to certain kinds of nodes (such
         as newly provisioned devices that need to establish a secure connection
         in order to boot up for the first time).</t>
      </list>
      </t>
      <t>With regard to PKIX certificates, servers SHOULD support both OCSP <xref target='RFC6960'/> and OCSP stapling. To enable interoperability with the widest range of clients, servers SHOULD support both the status_request extension defined in <xref target='RFC6066'/> and the status_request_v2 extension defined in <xref target='RFC6961'/>. Servers also SHOULD support the OCSP stapling extension defined in <xref target='RFC6961'/> as a best practice given the current state of the art and as a foundation for a possible future solution.</t>
      <t>The foregoing considerations do not apply to scenarios where the DANE-TLSA resource record <xref target='RFC6698'/> is used to signal to a client which certificate a server considers valid and good to use for TLS connections.</t>
      </section>
        
    </section>

    <section title="Acknowledgments" anchor="d1e1127">
      <t>We would like to thank Uri Blumenthal, Viktor Dukhovni, Stephen Farrell, Daniel Kahn Gillmor, Paul Hoffman, Simon Josefsson, Watson Ladd, Orit Levin, Ilari Liusvaara, Johannes Merkle, Bodo Moeller, Yoav Nir, Massimiliano Pala, Kenny Paterson, Patrick Pelletier, Tom Ritter, Joe St. Sauver, Joe Salowey, Rich Salz, Brian Smith, Sean Turner, and Aaron Zauner for their feedback and suggested improvements. Thanks to Brian Smith, who has provided a great resource in his "Proposal to Change the Default TLS Ciphersuites Offered by Browsers" <xref target='Smith2013'/>. Finally, thanks to all others who commented on the TLS, UTA, and other discussion lists but who are not mentioned here by name.</t>
    </section>

  </middle>

  <back>
    <references title="Normative References">
<?rfc include="reference.RFC.2119.xml"?>
<?rfc include="reference.RFC.2818.xml"?>
<?rfc include="reference.RFC.3766.xml"?>
<?rfc include="reference.RFC.4492.xml"?>
<?rfc include="reference.RFC.5246.xml"?>
<?rfc include="reference.RFC.5288.xml"?>
<?rfc include="reference.RFC.5289.xml"?>
<?rfc include="reference.RFC.5746.xml"?>
<?rfc include="reference.RFC.6125.xml"?>
<?rfc include="reference.RFC.6176.xml"?>
<?rfc include="reference.RFC.6347.xml"?>
    </references>

    <references title="Informative References">

<?rfc include="reference.I-D.farrelll-mpls-opportunistic-encrypt.xml"?>
<?rfc include="reference.I-D.ietf-dane-smtp-with-dane.xml"?>
<?rfc include="reference.I-D.ietf-dane-srv.xml"?>
<?rfc include="reference.I-D.ietf-tls-downgrade-scsv"?>
<?rfc include="reference.I-D.ietf-tls-prohibiting-rc4.xml"?>
<?rfc include="reference.I-D.ietf-uta-tls-attacks.xml"?>
<?rfc include="reference.RFC.2246.xml"?>
<?rfc include="reference.RFC.3602.xml"?>
<?rfc include="reference.RFC.4346.xml"?>
<?rfc include="reference.RFC.4347.xml"?>
<?rfc include="reference.RFC.4949.xml"?>
<?rfc include="reference.RFC.5077.xml"?>
<?rfc include="reference.RFC.5116.xml"?>
<?rfc include="reference.RFC.5280.xml"?>
<?rfc include="reference.RFC.6066.xml"?>
<?rfc include="reference.RFC.6090.xml"?>
<?rfc include="reference.RFC.6101.xml"?>
<?rfc include="reference.RFC.6460.xml"?>
<?rfc include="reference.RFC.6698.xml"?>
<?rfc include="reference.RFC.6797.xml"?>
<?rfc include="reference.RFC.6960.xml"?>
<?rfc include="reference.RFC.6961.xml"?>
<?rfc include="reference.RFC.6989.xml"?>

<reference anchor="POODLE" target="https://www.openssl.org/~bodo/ssl-poodle.pdf"><front><title>This POODLE Bites: Exploiting the SSL 3.0 Fallback</title><author initials="B." surname="Moeller" fullname="Bodo Moeller"/><author initials="T." surname="Duong" fullname="Thai Duong"/><author initials="K." surname="Kotowicz" fullname="Krzysztof Kotowicz"/><date year="2014"/></front></reference>
<reference anchor="triple-handshake" target="https://secure-resumption.com/"><front><title>Triple Handshakes Considered Harmful:
Breaking and Fixing Authentication over TLS</title>
<author initials="A." surname="Delignat-Lavaud" fullname="Antoine Delignat-Lavaud"></author>
<author initials="K." surname="Bhargavan" fullname="Karthikeyan Bhargavan"></author>
<author initials="A." surname="Pironti" fullname="Alfredo Pironti"></author><date year="2014"/>
</front></reference>
<reference anchor="CAB-Baseline" target="https://www.cabforum.org/documents.html"><front><title>Baseline Requirements for the Issuance and Management of Publicly-Trusted Certificates Version 1.1.6</title><author fullname="CA/Browser Forum" initials="" surname="CA/Browser Forum"></author><date year="2013"/></front></reference>
<reference anchor="ECRYPT-II" target="http://www.ecrypt.eu.org/documents/D.SPA.20.pdf"><front><title>ECRYPT II Yearly Report on Algorithms and Keysizes (2011-2012)</title><author fullname="Nigel Smart (ed.)" initials="N." surname="Smart"></author><date year="2012"/></front></reference>
<reference anchor="Heninger2012"><front><title>Mining Your Ps and Qs: Detection of Widespread Weak Keys in Network Devices</title><author initials="N." surname="Heninger" fullname="Nadia Heninger"/><author initials="Z." surname="Durumeric" fullname="Zakir Durumeric"/><author initials="E." surname="Wustrow" fullname="Eric Wustrow"/><author initials="J.A." surname="Halderman" fullname="J. Alex Halderman"/><date year="2012"/></front><seriesInfo name="Usenix Security Symposium" value="2012"/></reference>
<reference anchor="Kleinjung2010" target="https://eprint.iacr.org/2010/006.pdf"><front><title>Factorization of a 768-Bit RSA Modulus</title><author initials="T." surname="Kleinjung" fullname="Thorsten Kleinjung"/><date year="2010"/></front><seriesInfo name="CRYPTO" value="10"/></reference>
<reference anchor="Soghoian2011"><front><title>Certified lies: Detecting and defeating government interception attacks against SSL.</title><author initials="C." surname="Soghoian" fullname="Christopher Soghoian"/><author initials="S." surname="Stamm" fullname="Sid Stamm"/><date year="2011"/></front><seriesInfo name="Proc. 15th Int. Conf. Financial Cryptography and Data Security" value=""/></reference>
<reference anchor="PatersonRS11" target="http://dx.doi.org/10.1007/978-3-642-25385-0_20"><front><title>Tag size does matter: attacks and proofs for the TLS record protocol</title><author fullname="Kenneth G. Paterson" initials="K. G." surname="Paterson" /><author fullname="Thomas Ristenpart" initials="T." surname="Ristenpart" /><author fullname="Thomas Shrimpton" initials="T." surname="Shrimpton" /><date year="2011" /></front></reference>
<reference anchor="DegabrieleP07" target="http://dx.doi.org/10.1109/SP.2007.8"><front><title>Attacking the IPsec standards in encryption-only configurations</title><author fullname="Jean Paul Degabriele" initials="J. P." surname="Degabriele" /><author fullname="Kenneth G. Paterson" initials="K. G." surname="Paterson" /><date year="2007" /></front></reference>
<reference anchor="Smith2013" target="https://briansmith.org/browser-ciphersuites-01.html"><front><title>Proposal to Change the Default TLS Ciphersuites Offered by Browsers.</title><author initials="B." surname="Smith" fullname="Brian Smith"/><date year="2013"/></front></reference>
</references>

    <section title="Change Log" anchor="changes">
      <t>
Note to RFC Editor: please remove this section before publication.</t>
      <section title="draft-ietf-uta-tls-bcp-08" anchor="changes-08">
        <t>
          <list style="symbols">
            <t>More WGLC feedback.</t>
	    <t>TLS 1.1 is now SHOULD NOT, just like TLS 1.0.</t>
	    <t>SHOULD NOT use curves of less than 192 bits for ECDH.</t>
            <t>Clarification regarding OCSP and OSCP stapling.</t>
          </list>
        </t>
      </section>
      <section title="draft-ietf-uta-tls-bcp-07" anchor="changes-07">
        <t>
          <list style="symbols">
            <t>WGLC feedback.</t>
          </list>
        </t>
      </section>
      <section title="draft-ietf-uta-tls-bcp-06" anchor="changes-06">
        <t>
          <list style="symbols">
            <t>Undo unauthenticated TLS, following another long thread on the list.</t>
          </list>
        </t>
      </section>
      <section title="draft-ietf-uta-tls-bcp-05" anchor="changes-05">
        <t>
          <list style="symbols">
	    <t>Lots of comments by Sean Turner.</t>
            <t>Unauthenticated TLS, following a long thread on the list.</t>
          </list>
        </t>
      </section>
      <section title="draft-ietf-uta-tls-bcp-04" anchor="changes-04">
        <t>
          <list style="symbols">
            <t>Some cleanup, and input from TLS WG discussion on applicability.</t>
          </list>
        </t>
      </section>
      <section title="draft-ietf-uta-tls-bcp-03" anchor="changes-03">
        <t>
          <list style="symbols">
            <t>Disallow truncated HMAC.</t>
	    <t>Applicability to DTLS.</t>
	    <t>Some more text restructuring.</t>
	    <t>Host name validation is sometimes irrelevant.</t>
	    <t>HSTS: MUST implement, SHOULD deploy.</t>
	    <t>Session identities are not protected, only tickets are.</t>
	    <t>Clarified the target audience.</t>
          </list>
        </t>
      </section>
      <section title="draft-ietf-uta-tls-bcp-02" anchor="changes-02">
        <t>
          <list style="symbols">
            <t>Rearranged some sections for clarity and re-styled the text so that normative
	    text is followed by rationale where possible.</t>
	    <t>Removed the recommendation to use Brainpool curves.</t>
	    <t>Triple Handshake mitigation.</t>
	    <t>MUST NOT negotiate algorithms lower than 112 bits of security.</t>
	    <t>MUST implement SNI, but use per local policy.</t>
	    <t>Changed SHOULD NOT negotiate or fall back to SSLv3 to MUST NOT.</t>
	    <t>Added hostname validation.</t>
	    <t>Non-normative discussion of DH exponent reuse.</t>
          </list>
        </t>
      </section>
      <section title="draft-ietf-tls-bcp-01" anchor="changes-01">
        <t>
          <list style="symbols">
            <t>Clarified that specific TLS-using protocols may have stricter requirements.</t>
	    <t>Changed TLS 1.0 from MAY to SHOULD NOT.</t>
	    <t>Added discussion of "optional TLS" and HSTS.</t>
	    <t>Recommended use of the Signature Algorithm and Renegotiation Info extensions.</t>
	    <t>Use of a strong cipher for a resumption ticket: changed SHOULD to MUST.</t>
	    <t>Added an informational discussion of certificate revocation, but no recommendations.</t>
          </list>
        </t>
      </section>
      <section title="draft-ietf-tls-bcp-00" anchor="changes-00">
        <t>
          <list style="symbols">
            <t>Initial WG version, with only updated references.</t>
          </list>
        </t>
      </section>
      <section title="draft-sheffer-tls-bcp-02" anchor="changes-pre02">
        <t>
          <list style="symbols">
            <t>Reorganized the content to focus on recommendations.</t>
            <t>Moved description of attacks to a separate document (draft-sheffer-uta-tls-attacks).</t>
            <t>Strengthened recommendations regarding session resumption.</t>
          </list>
        </t>
      </section>
      <section title="draft-sheffer-tls-bcp-01" anchor="changes-pre01">
        <t>
          <list style="symbols">
            <t>Clarified our motivation in the introduction.</t>
            <t>Added a section justifying the need for forward secrecy.</t>
            <t>Added recommendations for RSA and DH parameter lengths. Moved from DHE to ECDHE, with a discussion on whether/when DHE is appropriate.</t>
            <t>Recommendation to avoid fallback to SSLv3.</t>
            <t>Initial information about browser support - more still needed!</t>
            <t>More clarity on compression.</t>
            <t>Client can offer stronger cipher suites.</t>
            <t>Discussion of the regular TLS mandatory cipher suite.</t>
          </list>
        </t>
      </section>
      <section title="draft-sheffer-tls-bcp-00" anchor="changes-pre00">
        <t>
          <list style="symbols">
            <t>Initial version.</t>
          </list>
        </t>
      </section>
    </section>
  </back>
</rfc>
